package No8_ConcurrentProgramm

/*
	并发介绍:
        进程和线程:
            进程: 是程序在操作系统中的一次执行过程, 系统进行资源分配和调度的一个独立单位
            线程: 是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位
            进程和线程的关系: 一个进程可以创建和撤销多个线程, 同一个进程中的多个线程之间可以并发执行
        并发和并行:
            并发: 多线程程序在一个核的cpu上运行, 主要由切换时间片来实现"同时运行"
            并行: 多线程程序在多个核的cpu上运行, 直接利用多核实现多线程的运行, Go语言中可以设置使用核数, 以发挥多核计算机的能力
        协程和线程:
            协程: 独立的栈空间, 共享堆空间, 调度由用户自己控制, 本质上有点类似于用户级线程, 这些用户级线程的调度也是自己实现的
            线程和协程的关系: 一个线程上可以跑多个协程, 协程是轻量级的线程
	Go语言并发实现 ==> goroutine:
		goroutine的概念类似于线程, 是由Go的运行时(runtime)调度和管理的, Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU
		goroutine 奉行通过通信来共享内存, 而不是共享内存来通信
		Go语言中并发实现: 将相关代码包装成一个函数, 然后由goroutine去执行这个函数
        使用goroutine:
            Go语言中使用goroutine, 只需要在调用函数时在函数名前加上"go"关键字, 即可为函数创建一个goroutine(子协程)
			格式: go funcName(参数列表)
		注意:
            1. 一旦主协程结束, 子协程也会被强制结束, 往往一般主协程是比较快的, 如果不做特殊处理, 在子协程来不及执行时, 主协程就已经
            执行完毕！！
			2. 通过 "go" 关键字执行的函数是没有返回值的, 如果定义函数有返回值, 则返回值会被丢弃
	sync.WaitGroup ==> 用于等待一组线程的结束, 可用于解决主线程与子线程同步问题
		func (wg *WaitGroup) Add(delta int): Add方法向内部计数加上delta, delta可以是负数
		func (wg *WaitGroup) Done(): 每次调用将 WaitGroup 计数器的值减一
		func (wg *WaitGroup) Wait(): 阻塞直到 WaitGroup 计数器减为 0
		使用步骤:
			1. 定义全局变量, sync.WaitGroup类型
			2. 在指定位置调用 Add(delta int)方法, 修改计数器值
			3. 在目标协程函数内部使用 defer 关键字延迟调用 Done()方法, 将计数器值减一(执行完一个子协程, 计算器减一)
			4. 在指定位置调用 Wait()方法, 阻塞主线程, 并等待子线程全部结束
*/
